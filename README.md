# 实现思路及运行结果
---
## Matrix add_matrix(Matrix a, Matrix b);
**加法运算**
（要求两个矩阵的维度相同，并且元素个数相同。）
实现方法是验证两个矩阵的维度相同后将两个矩阵对应位置的元素相加。
---
运行结果如下：
![加法](test\add.png)
---
## Matrix sub_matrix(Matrix a, Matrix b);
**减法运算**
（要求两个矩阵的维度相同，并且元素个数相同。）
实现方法是验证两个矩阵的维度相同后将两个矩阵对应位置的元素相减。
---
运行结果如下：
![减法](test\sub.png)
---
## Matrix mul_matrix(Matrix a, Matrix b);
**乘法运算**
（要求两个矩阵的维度相等，并且元素个数相同。）
实现方法是验证前一个矩阵列的规模与后一个矩阵行的规模相同，然后将前一个矩阵第i行第k列的元素与后一个矩阵第k行第j列的元素相乘后相加，并将结果保存在第i行第j列的位置。
---
运行结果如下：
![乘法](test\mul.png)
---
## Matrix scale_matrix(Matrix a, double k);
**数乘运算**
实现方法是将矩阵每个元素乘以常数k。
---
运行结果如下：
![数乘](test\scale.png)
---
## Matrix transpose_matrix(Matrix a);
**转置运算**
实现方法是新建一个矩阵，其行规模是原矩阵的列规模，其列规模是原矩阵的行规模，新建矩阵第i行第j列的元素是原矩阵第j行第i列的元素。
---
运行结果如下：
![转置](test\transpose.png)
---
## double det_matrix(Matrix a);
**行列式运算**
实现方法是先判断原矩阵是否为方阵，如果不是方阵，则报错，如果是方阵，则将原先的矩阵按第一行展开，用第一行的元素乘以其对应的代数余子式便是行列式的值。对应的代数余子式的求法是通过递归运算，以矩阵只有一行一列作为递归出口的运算。
---
运行结果如下：
![行列式](test\det.png)
---
## Matrix inv_matrix(Matrix a);
**求逆运算**
实现方法是先判断原矩阵是否为方阵，如果不是方阵，则报错，如果是方阵，则求原矩阵的行列式的值，如果行列式的值为0，则报错，如果行列式的值不为0，则求原矩阵的逆矩阵。求逆矩阵的方法是计算原矩阵的伴随矩阵和行列式的值，然后将伴随矩阵除以行列式的值即为所求的逆矩阵。
---
运行结果如下：
![求逆](test\inv.png)
---
## int rank_matrix(Matrix a);
**矩阵的秩**
实现方法是使用高斯消元法将矩阵化为上三角矩阵，矩阵的秩就是非零行的行数。
---
运行结果如下：
![秩](test\rank.png)
---
## double trace_matrix(Matrix a);
**矩阵的迹**
实现方法是验证矩阵是方阵之后将矩阵对角线上元素相加。
---
运行结果如下：
![迹](test\trace.png)
---